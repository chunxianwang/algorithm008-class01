学习笔记
## c++重载操作符(operator)
### 1.what?
operator 是C++的关键字，它和运算符（如=）一起使用，表示一个**运算符重载函数**，在理解时可将operator和运算符（如operator=）视为一个函数名。

使用operator重载运算符，是C++扩展运算符功能的方法。使用operator扩展运算符功能的原因如下：

### 2.why?
**面向用户自己定义的类**
对于C++提供的所有操作符，通常只支持对于基本数据类型和标准库中提供的类的操作;
而对于**用户自己定义的类**，如果想要通过该操作符实现一些基本操作（比如比较大小，判断是否相等），就需要用户自己来定义关于这个操作符的具体实现了。

比如，我们要设计一个名为“person”的类，现在要判断person类的两个对象p1和p2是否一样大，我们设计的比较规则是按照其年龄来比较，那么，在设计person类的时候，就可以通过对操作符“==”进行重载，来使用操作符“==”对对象p1和p2进行比较了（实际上比较的内容应该是person类中的数据成员“age”）。

我们上面说的对操作符“==”进行重载，说是“重载”，是由于编译器在实现操作符“==”功能的时候，已经为我们提供了这个操作符对于一些基本数据类型的操作支持，只不过由于现在该操作符所操作的内容变成了我们自定义的数据类型（如class），而默认情况下，该操作符是不能对我们自定义的class类型进行操作的，所以，就需要我们通过重载该操作符，给出该操作符操作我们自定义的class类型的方法，从而达到使用该操作符对我们自定义的class类型进行运算的目的。

### 3.how？
**格式** 
```c++
type operator>(const class& obj1, const class& obj2) {
    this->value...
    obj1.value...
    obj2.balue...
}
```
**位置**
实现一个操作符重载的方式通常分为两种情况：
* 将操作符重载实现为类的成员函数；
* 操作符重载实现为非类的成员函数（即全局函数）。
**示例**
```c++
#include <iostream>
using namespace std;
class person {
private:
    int age;
public:
    person(int nAge){
        this->age = nAge;
    }
    bool operator==(const person& ps){
        if (this->age == ps.age){
            return true;
        }
        return false;
    }
};

int main()
{
    person p1(10);
    person p2(10);
    if (p1 == p2) cout << "p1 is equal with p2." << endl;
    else cout << "p1 is not equal with p2." << endl;
    return 0;
}
```

```c++
#include <iostream>
using namespace std;
class person {
public:
    int age;
};
// 左操作数的类型必须被显式指定
// 此处指定的类型为person类
bool operator==(person const& p1 ,person const& p2) {
    if (p1.age == p2.age) return true;
    else return false;
}
int main()
{
    person p1;
    person p2;
    p1.age = 18;
    p2.age = 18;
    if (p1 == p2) cout << "p1 is equal with p2." << endl;
    else cout << "p1 is NOT equal with p2." << endl;
    return 0;
}
```
#### 操作符重载的方式选择
可以根据以下因素，确定把一个操作符重载为类的成员函数还是全局函数：
如果一个重载操作符是类成员，那么只有当与它一起使用的左操作数是该类的对象时，该操作符才会被调用；而如果该操作符的左操作数确定为其他的类型，则操作符必须被重载为全局函数；
C++要求'='、'[]'、'()'、'->'操作符必须被定义为类的成员操作符，把这些操作符通过全局函数进行重载时会出现编译错误
如果有一个操作数是类类型（如string类），那么对于对称操作符（比如==操作符），最好通过全局函数的方式进行重载。
#### 操作符重载的限制
实现操作符重载时，需要注意：
重载后操作符的操作数至少有一个是用户定义类型；
不能违反原来操作数的语法规则；
不能创建新的操作符；
不能重载的操作符包括（以空格分隔）：sizeof . .* :: ?: RTTI类型运算符
=、()、[]、以及 ->操作符只能被类的成员函数重载

## 位运算
* 奇偶判断
x%2 == 1  ==>  (x&1)==1  //奇数
x%2 == 0  ==>  (x&1)==0  //偶数

* 除以二
  x/2     ==>  x>>1

* 清零最低位的1
  x = x&(x-1)

* 得到最低位的1
  x&(-x)
* 得到0
  x&(~x) 

## 布隆过滤器
[原理和实现参考文章](https://www.cnblogs.com/cpselvis/p/6265825.html)

#### 什么时候使用？
布隆过滤器，一般用于快速查找某个元素是否在集合中。
* 字处理软件中，快速查询英语单词是否拼写正确？（输入单词是否在英语单词词典中）。
* 在网络爬虫里，一个网站是否访问过？
* yahoo 和 gmail等邮箱，垃圾邮件过滤功能。检查当前邮件是否在垃圾邮件集合中。

常常作为数据库的最外层，快速判断某个元素是否在数据库中，如果反馈不在其中，那就肯定不在其中了；如果反馈在其中，那就是可能在其中，也可能不在，需要进入数据库做更多查询操作。

#### 实现原理
核心实现两部分：
位数组，存放很多0和1元素的数组；
哈希函数，待查询元素，通过哈希函数，得到对应的位数组中的某些位数据。

和哈希表类似，对某个元素，通过3个哈希函数映射得到对应的位数组（比如对应位素组中的3位），如果这3位都是1，那么此元素可能存在；如果3位不全部是1，那么此元素一定不存在。

**布隆过滤器元素添加**
* 将要添加的元素给k个哈希函数
* 得到对应于位数组上的k个位置
* 将这k个位置设为1

**布隆过滤器查询元素**
* 将要查询的元素给k个哈希函数
* 得到对应于位数组上的k个位置
* 如果k个位置有一个为0，则肯定不在集合中
* 如果k个位置全部为1，则可能在集合中

**对比哈希表**，布隆过滤器占用空间小，查询速度更快，尤其是快速得到某元素不在集合中。

## LRU Cache (least recently used cache)

**LRU缓存操作原理**
头部放最新访问数据，尾部放很久前访问的数据；
1.访问数据，查询待访问数据地址，若有，返回此地址中存储的值，并把它放入头部；
2.存入数据，查询待访问数据地址，若有，把它调整到头部；若无，把它插入到头部，并判断cache是否溢出（超过其capacity），若溢出，删掉尾部；

LRU的get，put操作的两个关键元素：key 和 value， 理解成cache的地址索引和其中存储的值；
note，为区别哈希列表和cache，在下述哈希列表中，用键和值表述hash_map的key和value；
双端链表，cache的数据存储。 key，对应于cache的key，就是cache的地址索引；value，对应于cache的value，实际存放的数据；
哈希列表，键，对应于cache的key，就是cache的地址索引； 值，对应于链表的结点的地址；

**为什么不用单链表**
单链表，只定义了head，如果想要快速访问tail，要逐个从头部到尾部遍历，时间复杂度O(n)；不适用于用O(1)访问和删除尾部的场景；
而双链表，定义了head和tail，访问和删除尾部时，就比较迅速了;

通俗说就是，单链表能实现新来的放头部，最久不用的在尾部删除。但删除的时候需要遍历到尾部，因为单链表只有头指针。在用到已经用到过的数据时，还要遍历整合链表，来确定是否用过，然后再遍历到响应位置来剔除的节点，并重新放在头部。这效率可想而知。

## 排序
![各类排序算法比较](https://gitee.com/chunxianwang/ImageHost/raw/master/uPic/VRnCjZ.jpg)
一般排序时间复杂度是O(N^2),重点学习三种O(NlogN)的排序方法；
* 快速排序
* 归并排序
* 堆排序

### 快速排序
分治思想：局部问题解决，合起来就把整体问题解决了。
练习题目:[912.排序数组](912.排序数组.cpp)
**快速排序思想**
1. 在序列中随机找一个数作为标杆；
2. 遍历序列，小于标杆的放在左侧，大于标杆的放在右侧；效果是为标杆找到了排序序列中的合适位置。
3. 在标杆左侧子序列中选取一个新的标杆，重复过程2。
4. 直到处理完所有最小粒度（2或3个元素）的子序列。

**具体操作实现**
[参考文章-快速排序法（详解）](https://blog.csdn.net/qq_40941722/article/details/94396010?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)

**优化原理**
快速排序之所以比较快，是因为与冒泡排序相比，每次的交换是跳跃式的；
每次排序的时候设置一个标杆，将小于等于标杆的数全部放到标杆的左边，将大于等于标杆的数全部放到标杆的右边。
这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，**交换的距离就大的多了**。
因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(n^2)，它的平均时间复杂度O(nlog2n)。

### 归并排序
快速排序核心思想：用标杆将序列一分为二，左右有序列，但左右内部无序；递归分成更小子序列；
**归并排序恰巧与快排思想相反**：
序列一分为二，且通过递归分成很小子序列，先对两个小的子序列内部排序，再把两个子序列合并；

### 堆排序
利用大顶堆和小顶堆的特性，
c++ 中使用stl中的priority_queue来实现；
[参考stl：priority_queue用法详解](http://c.biancheng.net/view/480.html)
其中priority_queue::push(), priority_queue::pop()时间复杂度都是O(logn)的。
n个元素，那么整体时间复杂度O(nlogn)。


