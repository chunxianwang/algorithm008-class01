学习笔记
## c++重载操作符(operator)
### 1.what?
operator 是C++的关键字，它和运算符（如=）一起使用，表示一个**运算符重载函数**，在理解时可将operator和运算符（如operator=）视为一个函数名。

使用operator重载运算符，是C++扩展运算符功能的方法。使用operator扩展运算符功能的原因如下：

### 2.why?
**面向用户自己定义的类**
对于C++提供的所有操作符，通常只支持对于基本数据类型和标准库中提供的类的操作;
而对于**用户自己定义的类**，如果想要通过该操作符实现一些基本操作（比如比较大小，判断是否相等），就需要用户自己来定义关于这个操作符的具体实现了。

比如，我们要设计一个名为“person”的类，现在要判断person类的两个对象p1和p2是否一样大，我们设计的比较规则是按照其年龄来比较，那么，在设计person类的时候，就可以通过对操作符“==”进行重载，来使用操作符“==”对对象p1和p2进行比较了（实际上比较的内容应该是person类中的数据成员“age”）。

我们上面说的对操作符“==”进行重载，说是“重载”，是由于编译器在实现操作符“==”功能的时候，已经为我们提供了这个操作符对于一些基本数据类型的操作支持，只不过由于现在该操作符所操作的内容变成了我们自定义的数据类型（如class），而默认情况下，该操作符是不能对我们自定义的class类型进行操作的，所以，就需要我们通过重载该操作符，给出该操作符操作我们自定义的class类型的方法，从而达到使用该操作符对我们自定义的class类型进行运算的目的。

### 3.how？
**格式** 
```c++
type operator>(const class& obj1, const class& obj2) {
    this->value...
    obj1.value...
    obj2.balue...
}
```
**位置**
实现一个操作符重载的方式通常分为两种情况：
* 将操作符重载实现为类的成员函数；
* 操作符重载实现为非类的成员函数（即全局函数）。
**示例**
```c++
#include <iostream>
using namespace std;
class person {
private:
    int age;
public:
    person(int nAge){
        this->age = nAge;
    }
    bool operator==(const person& ps){
        if (this->age == ps.age){
            return true;
        }
        return false;
    }
};

int main()
{
    person p1(10);
    person p2(10);
    if (p1 == p2) cout << "p1 is equal with p2." << endl;
    else cout << "p1 is not equal with p2." << endl;
    return 0;
}
```

```c++
#include <iostream>
using namespace std;
class person {
public:
    int age;
};
// 左操作数的类型必须被显式指定
// 此处指定的类型为person类
bool operator==(person const& p1 ,person const& p2) {
    if (p1.age == p2.age) return true;
    else return false;
}
int main()
{
    person p1;
    person p2;
    p1.age = 18;
    p2.age = 18;
    if (p1 == p2) cout << "p1 is equal with p2." << endl;
    else cout << "p1 is NOT equal with p2." << endl;
    return 0;
}
```
#### 操作符重载的方式选择
可以根据以下因素，确定把一个操作符重载为类的成员函数还是全局函数：
如果一个重载操作符是类成员，那么只有当与它一起使用的左操作数是该类的对象时，该操作符才会被调用；而如果该操作符的左操作数确定为其他的类型，则操作符必须被重载为全局函数；
C++要求'='、'[]'、'()'、'->'操作符必须被定义为类的成员操作符，把这些操作符通过全局函数进行重载时会出现编译错误
如果有一个操作数是类类型（如string类），那么对于对称操作符（比如==操作符），最好通过全局函数的方式进行重载。
#### 操作符重载的限制
实现操作符重载时，需要注意：
重载后操作符的操作数至少有一个是用户定义类型；
不能违反原来操作数的语法规则；
不能创建新的操作符；
不能重载的操作符包括（以空格分隔）：sizeof . .* :: ?: RTTI类型运算符
=、()、[]、以及 ->操作符只能被类的成员函数重载

## 位运算
* 奇偶判断
x%2 == 1  ==>  (x&1)==1  //奇数
x%2 == 0  ==>  (x&1)==0  //偶数

* 除以二
  x/2     ==>  x>>1

* 清零最低位的1
  x = x&(x-1)

* 得到最低位的1
  x&(-x)
* 得到0
  x&(~x) 

## 布隆过滤器
[原理和实现参考文章](https://www.cnblogs.com/cpselvis/p/6265825.html)

#### 什么时候使用？
布隆过滤器，一般用于快速查找某个元素是否在集合中。
* 字处理软件中，快速查询英语单词是否拼写正确？（输入单词是否在英语单词词典中）。
* 在网络爬虫里，一个网站是否访问过？
* yahoo 和 gmail等邮箱，垃圾邮件过滤功能。检查当前邮件是否在垃圾邮件集合中。

常常作为数据库的最外层，快速判断某个元素是否在数据库中，如果反馈不在其中，那就肯定不在其中了；如果反馈在其中，那就是可能在其中，也可能不在，需要进入数据库做更多查询操作。

#### 实现原理
核心实现两部分：
位数组，存放很多0和1元素的数组；
哈希函数，待查询元素，通过哈希函数，得到对应的位数组中的某些位数据。

和哈希表类似，对某个元素，通过3个哈希函数映射得到对应的位数组（比如对应位素组中的3位），如果这3位都是1，那么此元素可能存在；如果3位不全部是1，那么此元素一定不存在。

**布隆过滤器元素添加**
* 将要添加的元素给k个哈希函数
* 得到对应于位数组上的k个位置
* 将这k个位置设为1

**布隆过滤器查询元素**
* 将要查询的元素给k个哈希函数
* 得到对应于位数组上的k个位置
* 如果k个位置有一个为0，则肯定不在集合中
* 如果k个位置全部为1，则可能在集合中

**对比哈希表**，布隆过滤器占用空间小，查询速度更快，尤其是快速得到某元素不在集合中。

## LRU Cache (least recently used cache)
